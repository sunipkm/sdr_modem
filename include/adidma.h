/**
 * @file adidma.h
 * @author Sunip K. Mukherjee (sunipkmukherjee@gmail.com)
 * @brief Header file describing functions required to execute DMA transfers \
 * using ADI AXI DMA Controllers.
 * @version 0.1
 * @date 2020-10-29
 * 
 * @copyright Copyright (c) 2020
 * 
 */
#ifndef __ADIDMA_H
#define __ADIDMA_H

/**
 * @brief Defines the interrupt timeout for RX DMA in milliseconds. Setting this
 * variable to -1 would imply that the poll() call hang forever. NOT
 * RECOMMENDED. Use a positive value for this constant ONLY.
 * 
 */
extern const int ADIDMA_RX_DMA_TIMEOUT;

typedef enum
{
    /**
     * @brief Version of the peripheral. 
     * [31:16] == Major version
     * [15:8] == Minor version
     * [7:0] == Version Patch
     */
    DMAC_REG_VER = 0x0,
    /**
     * @brief Value of the ID configuration parameter
     */
    DMAC_REG_PERIPHERAL_ID = 0x4,
    /**
     * @brief Identification: Reads 0x444d414c ("D M A C") 
     */
    DMAC_REG_ID = 0xc,
    /**
     * @brief Describes the interface
     * [13:12] == DMA_TYPE_SRC. 0 => AXI MMap, 1 => AXI Stream, 2 => FIFO
     * [11:8] == Width of data bus on src side. Log2 of interface data widths in bytes
     * [5:4] == DMA_TYPE_DEST
     * [3:0] == Width of data bus on dest side. Log2 of interface data widths in bytes
     */
    DMAC_REG_IFACE_DESCRIPTION = 0x10,
    /**
     * @brief Masks the selected IRQ when the corresponding bit is set.
     * [1] == Transfer completed (EOT => End of transfer)
     * [0] == Transfer queued (SOT => Start of transfer)
     */
    DMAC_REG_IRQ_MASK = 0x80,
    /**
     * @brief Indicates status of the unmasked interrupts
     * [1] == This bit will be asserted if a transfer has been completed and the
     * TRANSFER_COMPLETED bit in the IRQ_MASK register is not set, either after
     * all bytes have been transferred or because of an error occurred during
     * the transfer. Assert this bit to clear the interrupt. The assertion can
     * be done to IRQ_SOURCE register as well with the same effect.
     * 
     * [0] == This bit will be asserted if a transfer has been queued and
     * it is possible to queue the next transfer. It can be masked out by
     * setting the TRANSFER_QUEUED bit in the IRQ_MASK register. Assert this bit 
     * to clear the interrupt. The assertion can be done to IRQ_SOURCE register 
     * as well with the same effect.
     */
    DMAC_REG_IRQ_PENDING = 0x84,
    /**
     * @brief Read description for IRQ_PENDING register.
     * 
     */
    DMAC_REG_IRQ_SOURCE = 0x88,
    /**
     * @brief Controls the DMA IP.
     * [1] == Pause. Assert this bit to pause the current active transfer.
     * Transfer resumes upon clearing this bit.
     * [0] == Enable. When asserted the DMA channel is enabled.
     */
    DMAC_REG_CTRL = 0x400,
    /**
     * @brief This register contains the ID of the next transfer. The ID is 
     * generated by the DMAC and after the transfer has been started can be used
     * to check if the transfer has finished by checking the corresponding bit 
     * in the TRANSFER_DONE register. The contents of this register is only 
     * valid if TRANSFER_SUBMIT is 0.
     */
    DMAC_REG_XFER_ID = 0x404,
    /**
     * @brief Writing a 1 to this register queues a new transfer. The bit 
     * transitions back to 0 once the transfer has been queued or the DMA 
     * channel is disabled. Writing a 0 to this register has no effect.
     */
    DMAC_REG_START_XFER = 0x408,
    /**
     * @brief Controls attributes of the DMA transfer.
     * [2] PARTIAL_REPORTING_EN == When this bit is asserted the lenght of
     * partial transfer caused eventually by TLAST will be recorded.
     * 
     * [1] TLAST == When setting this bit for a MM to AXIS transfer the TLAST
     * signal will be asserted during the last beat of the transfer.
     * For AXIS to MM transfers teh TLAST signal from the AXIS interface is
     * monitored. After its occurrence all descriptors are ignored until this
     * bit is set.
     * 
     * [0] CYCLIC == Setting this bit to 1 puts the DMA transfer into cyclic
     * mode. In cyclic mode the controller will restart a transfer again once it
     * has finished. In cyclic mode, no EOT interrupts will be generated.
     * 
     */
    DMAC_REG_FLAGS = 0x40c,
    /**
     * @brief This register contains the destination address of the transfer. 
     * The address needs to be aligned to the bus width. This register is only 
     * valid if the DMA channel has been configured for write to memory support.
     * 
     */
    DMAC_REG_DEST_ADDR = 0x410,
    /**
     * @brief This register contains the source address of the transfer. The 
     * address needs to be aligned to the bus width. This register is only valid
     * if the DMA channel has been configured for read from memory support.
     * 
     */
    DMAC_REG_SRC_ADDR = 0x414,
    /**
     * @brief [23:0] log2(max(DMA_DATA_WIDTH_SRC, DMA_DATA_WIDTH_DEST)/8)
     * Number of bytes to transfer - 1
     * 
     */
    DMAC_REG_X_LEN = 0x418,
    /**
     * @brief [23:0] Number of rows to transfer - 1. Note, this field is only
     * valid if the DMA channel has been configured with 2D transfer support
     * (in HDL as well as software)
     * 
     */
    DMAC_REG_Y_LEN = 0x41c,
    /**
     * @brief The number of bytes between the start of one row and the next row
     * for the destination address. Needs to be aligned with the bus width.
     * Note, this field is only valid if the DMA channel has been configured
     * with 2D transfer support AND write to memory support.
     * 
     */
    DMAC_REG_DEST_STRIDE = 0x420,
    /**
     * @brief The number of bytes between the start of one row and the next row
     * for the destination address. Needs to be aligned with the bus width.
     * Note, this field is only valid if the DMA channel has been configured
     * with 2D transfer support AND read from memory support.
     * 
     */
    DMAC_REG_SRC_STRIDE = 0x424,
    /**
     * @brief Indicates status of transfers.
     * [0] TRANSFER_0_DONE == This bit asserts transfer with ID 0 is finished.
     * [1] TRANSFER_1_DONE == This bit asserts transfer with ID 1 is finished.
     * [2] TRANSFER_2_DONE == This bit asserts transfer with ID 2 is finished.
     * [3] TRANSFER_3_DONE == This bit asserts transfer with ID 3 is finished.
     * 
     * [31] PARTIAL_TRANSFER == This bit indicates at least one partial transfer
     * was successful. This field will reset when the ENABLE_CONTROL bit is
     * reset or when all the information on the partial transfer were read
     * through PARTIAL_XFER_LENGTH and PARTIAL_XFER_ID registers.
     */
    DMAC_REG_XFER_DONE = 0x428,
    /**
     * @brief [4:0] ID of the currenctly active transfer. When no transfer is
     * active this register will be equal to the XFER_ID register.
     * 
     */
    DMAC_REG_ACTIVE_XFER_ID = 0x42c,
    /**
     * @brief Reserved. Reading this will always return 0.
     * 
     */
    DMAC_REG_STATUS = 0x430,
    /**
     * @brief Address to which the next data sample is written to. This register
     * is only valid if the DMA channel has been configured for write to memory
     * support.
     * 
     */
    DMAC_REG_CURR_DEST_ADDR = 0x434,
    /**
     * @brief Address to which the next data sample is read from. This register
     * is only valid if the DMA channel has been configured for read from memory
     * support.
     * 
     */
    DMAC_REG_CURR_SRC_ADDR = 0x438,

    DMAC_REG_DBG0 = 0x43c,
    DMAC_REG_DBG1 = 0x440,
    /**
     * @brief [23:0] this field presents the number of bytes transferred to the
     * destination for the current transfer. This register will be cleared once
     * the transfer completes. Should be used for DEBUG PURPOSES ONLY.
     */
    DMAC_XFER_PROGRESS = 0x448,
    /**
     * @brief Length of the partial transfer in bytes. Represents the last
     * number of bytes recveived until the moment of TLAST assertion. This will
     * be smaller than the programmed length from the X_LENGTH and Y_LENGTH
     * registers.
     * 
     */
    DMAC_PARTIAL_XFER_LEN = 0x44c,
    /**
     * @brief ID of the transfer that was partial. MUST BE READ AFTER THE
     * PARTIAL_XFER_LEN REGISTER.
     * 
     */
    DMAC_PARTIAL_XFER_ID = 0x450
} ADIDMAC_REGISTERS;

#include "libuio.h"
#include <stdint.h>

typedef enum
{
    DMAC_CTRL_ENABLE = 1, /// Indicates the first bit of the DMAC_REG_CTRL register is set and thus enables the DMA.
    DMAC_CTRL_PAUSE = 2,  /// Asserts the second bit of the DMAC_REG_CTRL register and pauses a transfer.

    DMAC_IRQ_SOT = 1, /// Indicates start of transfer on the DMAC_REG_IRQ_PENDING or DMAC_REG_IRQ_SOURCE registers.
    DMAC_IRQ_EOT = 2  /// Indicates end of transfer on the DMAC_REG_IRQ_PENDING or DMAC_REG_IRQ_SOURCE registers.
} ADIDMAC_CTRL;

typedef enum
{
    ADIDMA_NULL_BUFFER = -20,
    ADIDMA_UIO_MALLOC_ERROR,
    ADIDMA_FNAME_ERROR,
    ADIDMA_FD_OPEN_ERROR,
    ADIDMA_FILE_READ_ERROR,
    ADIDMA_BUF_SIZE_ERROR,
    ADIDMA_BUF_MMAP_ERROR,
    ADIDMA_XFER_SZ_ERR,
} ADIDMAC_ERROR;

typedef enum
{
    ADIDMA_MEMCPY_TX = 1,
    ADIDMA_MEMCPY_RX,
    ADIDMA_MEMCPY_ALL
} ADIDMAC_MEMCPY;

/**
 * @brief Describes an ADI DMA device.
 * 
 */
typedef struct
{
    uio_dev *bus;                     /// UIO device descriptor
    uint32_t mem_sz;                  /// Size of the DMA buffer
    uint32_t mem_addr;                /// Address of the DMA buffer
    int mem_fd;                       /// File descriptor to the DMA buffer for access (virtual address)
    void *mem_virt_addr;              /// mmapped virtual address to the DMA buffer
    void *mapping_addr;               /// mmap to the head of the virtual address that needs to be unmapped
    unsigned int tx_check_completion; /// Set this variable to check for DMA transfer completion by busy-wait on the DMAC_REG_XFER_DONE register instead of TX IP transfer complete interrupt
} adidma;
/**
 * @brief This function initializes the ADI DMA UIO device with supplied 
 * parameters.
 * 
 * @param dev Pointer to adidma struct. Memory must be preallocated. 
 * @param uio_id ID of the UIO device to be used for this ADI DMA device.
 * @param ext_buffer_enb Set this variable with ADIDMA_MEMCPY_TX,
 * ADIDMA_MEMCPY_RX or ADIDMA_MEMCPY_ALL to use a different address for these
 * buffers and an additional copy operation to fill the DMA buffers.
 * 
 * @returns int Positive on success, negative on error 
 */
int adidma_init(adidma *dev, int uio_id, unsigned char ext_buffer_enb);
/**
 * @brief Closes all memory file descriptors and UIO descriptors for the ADI
 * DMA device.
 * 
 * @param dev ADI DMA device. dev is NOT freed by this function, memory
 * management is left to the function calling adidma_destroy(). 
 */
void adidma_destroy(adidma *dev);
/**
 * @brief Writes data to the ADI DMA FIFO interface specified by dev. This is a
 * non-blocking call when cyclic transfer is permitted.
 * 
 * @param dev adidma struct with device configuration
 * @param offset Offset to DMA engine memory region base address
 * @param size Length of input data buffer
 * @param cyclic Cyclic transfer mode. 0 to enable, 1 to disable.
 * @return int Positive on success, negative on error.
 */
int adidma_write(adidma *dev, unsigned int offset, ssize_t size, unsigned char cyclic);
/**
 * @brief Reads data from the ADI DMA streaming interface specified by dev. This
 * is a blocking call that returns when the data has been transferred.
 * 
 * @param dev adidma struct with device configuration
 * @param offset Offset to DMA engine memory region base address
 * care of by the caller function)
 * @param size Length of data to be received.
 * @return int Positive on success, negative on error.
 */
int adidma_read(adidma *dev, unsigned int offset, ssize_t size);
#endif // __ADIDMA_H